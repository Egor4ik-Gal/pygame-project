Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\r\nimport pygame\r\nimport os\r\nfrom random import randrange, shuffle, choice\r\n\r\nflag = True             # задаем переменные, загружаю картинки\r\nflag_minigames1 = False\r\nflag_minigames2 = False\r\nflag_minigames3 = False\r\nflag_minigames2_2 = False\r\nsize2 = w, h = 650, 350\r\nscreen = pygame.display.set_mode(size2)\r\nclock = pygame.time.Clock()\r\nfps = 60\r\nspeed = 10\r\nbg0 = pygame.image.load(r'data\\first_screen.png')\r\nbg0_1 = pygame.image.load(r'data\\authors.png')\r\nbg = pygame.image.load(r'data\\room1.png')\r\nbg2 = pygame.image.load(r'data\\room2sav3.png')\r\nbg3 = pygame.image.load(r'data\\room3sav3.png')\r\npr1 = pygame.image.load(r'data\\pers1.png')\r\npr2 = pygame.image.load(r'data\\pers1.1.png')\r\npr3 = pygame.image.load(r'data\\pers1.2.png')\r\npr4 = pygame.image.load(r'data\\pers1.22.png')\r\nbg0_butt1 = pygame.image.load(r'data\\firstbutt.png')\r\nbg0_butt2 = pygame.image.load(r'data\\secondbutt.png')\r\nbg0_butt3 = pygame.image.load(r'data\\back.png')\r\nbg_end = pygame.image.load(r'data\\end_screen.png')\r\nthing1 = pygame.image.load(r'data\\cup.png')\r\nthing2 = pygame.image.load(r'data\\TV.png')\r\nthing2_2 = pygame.image.load(r'data\\vali.png')\r\nthing3 = pygame.image.load(r'data\\micro.png')\r\npr2.set_colorkey((255, 255, 255))\r\n\r\nperson = pygame.sprite.Sprite()\r\nperson.image = pr1\r\nperson.rect = person.image.get_rect()\r\nperson.rect.x = 0\r\nperson.rect.y = h - 205\r\n\r\n\r\n##############################\r\n\r\n\r\ndef load_image(name, colorkey=None):      # функция для загрузки картинок\r\n    fullname = os.path.join('data', name)\r\n    image = pygame.image.load(fullname)\r\n    if colorkey is not None:\r\n        image = image.convert()\r\n        if colorkey == -1:\r\n            colorkey = image.get_at((0, 0))\r\n        image.set_colorkey(colorkey)\r\n    else:\r\n        image = image.convert_alpha()\r\n    return image\r\n\r\n\r\nclass Board:   # создается класс Board для клетчатого поля, ниже несколько мини-игр наследуются от него\r\n    def __init__(self, screen):\r\n        self.width = 10\r\n        self.height = 10\r\n        self.board = [[0] * 10 for _ in range(10)]\r\n        self.left = 175\r\n        self.top = 40\r\n        self.cell_size = 30\r\n        self.render(screen)\r\n\r\n    def set_view(self, left, top, cell_size):\r\n        self.left = left\r\n        self.top = top\r\n        self.cell_size = cell_size\r\n\r\n    def on_click(self, cell):\r\n        print(cell)\r\n\r\n    def get_cell(self, mouse_pos):\r\n        cell_x = (mouse_pos[0] - self.left) // self.cell_size\r\n        cell_y = (mouse_pos[1] - self.top) // self.cell_size\r\n        if cell_x < 0 or cell_x >= self.width or cell_y < 0 or cell_y >= self.height:\r\n            return None\r\n        return cell_x, cell_y\r\n\r\n    def get_click(self, mouse_pos):\r\n        cell = self.get_cell(mouse_pos)\r\n        if cell:\r\n            return self.on_click(cell)\r\n        # else:\r\n        #     print(cell)\r\n\r\n    def render(self, screen):\r\n        colors = [pygame.Color(\"black\"), pygame.Color(\"white\")]\r\n        for y in range(self.height):\r\n            for x in range(self.width):\r\n                # pygame.draw.rect(screen, colors[self.board[y][x]], (\r\n                #     x * self.cell_size + self.left, y * self.cell_size + self.top, self.cell_size,\r\n                #     self.cell_size))\r\n                pygame.draw.rect(screen, pygame.Color(\"white\"), (\r\n                    x * self.cell_size + self.left, y * self.cell_size + self.top, self.cell_size,\r\n                    self.cell_size), 1)\r\n\r\n\r\nclass Ball(pygame.sprite.Sprite):  # класс Ball для создания спрайтов в мини-игре CatchingBalls\r\n    def __init__(self, *group):\r\n        super().__init__(*group)\r\n        self.image = load_image(\"ball.png\")\r\n        self.rect = self.image.get_rect()\r\n        self.rect.x = 150 + randrange(315)\r\n        self.rect.y = 0\r\n\r\n\r\nclass CatchingBalls:  #\r\n    def __init__(self, screen, v=None):\r\n        global flag_minigames1, flag_minigames2, flag_minigames3, room, flag_minigames2_2\r\n        self.screen = screen\r\n        pygame.draw.rect(screen, (255, 255, 255), (150, 0, 350, 350))\r\n        pygame.draw.rect(screen, (200, 170, 100), (150, 400, 480, 80))\r\n        font = pygame.font.Font(None, 30)\r\n        text = font.render(\"Поймайте 30 шариков!\", True, (0, 0, 0))\r\n        text_x = 110\r\n        text_y = 10\r\n        screen.blit(text, (text_x, text_y))\r\n\r\n        self.all_sprites = pygame.sprite.Group()\r\n        self.basket = pygame.sprite.Sprite()\r\n        self.basket.image = load_image(\"basket.png\")\r\n        self.basket.rect = self.basket.image.get_rect()\r\n        self.all_sprites.add(self.basket)\r\n\r\n        self.basket.rect.x = 150\r\n        self.basket.rect.y = 250\r\n\r\n        self.hard1 = pygame.sprite.Sprite()\r\n        self.hard1.image = load_image(\"health.png\")\r\n        self.hard1.rect = self.basket.image.get_rect()\r\n        self.all_sprites.add(self.hard1)\r\n\r\n        self.hard1.rect.x = 465\r\n        self.hard1.rect.y = 10\r\n\r\n        self.hard2 = pygame.sprite.Sprite()\r\n        self.hard2.image = load_image(\"health.png\")\r\n        self.hard2.rect = self.basket.image.get_rect()\r\n        self.all_sprites.add(self.hard2)\r\n\r\n        self.hard2.rect.x = 435\r\n        self.hard2.rect.y = 10\r\n\r\n        self.hard3 = pygame.sprite.Sprite()\r\n        self.hard3.image = load_image(\"health.png\")\r\n        self.hard3.rect = self.basket.image.get_rect()\r\n        self.all_sprites.add(self.hard3)\r\n\r\n        self.hard3.rect.x = 405\r\n        self.hard3.rect.y = 10\r\n\r\n        self.all_sprites.draw(screen)\r\n\r\n        # pygame.display.flip()\r\n        # self.playing()\r\n        if self.playing():\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы победили!!!\", True, (100, 255, 100))\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n            if room == 1:\r\n                flag_minigames1 = True\r\n            elif room == 2 and v == 0:\r\n                flag_minigames2 = True\r\n            elif room == 2 and v == 1:\r\n                flag_minigames2_2 = True\r\n            elif room == 3:\r\n                flag_minigames3 = True\r\n            running3()\r\n\r\n        else:\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы проиграли!!!\", True, (255, 0, 0))\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n            running3()\r\n\r\n    def playing(self):\r\n        running = True\r\n\r\n        CREATINGBALLS = pygame.USEREVENT + 1\r\n        FALL = pygame.USEREVENT + 2\r\n        pygame.time.set_timer(CREATINGBALLS, 900)\r\n        count_of_fallen_balls = 0\r\n        count_of_catched_balls = 0\r\n        count = 0\r\n        list_of_balls = []\r\n        while running:\r\n            self.screen.fill((0, 0, 0))\r\n            for event in pygame.event.get():\r\n                if event.type == pygame.QUIT:\r\n                    running = False\r\n                if event.type == CREATINGBALLS:\r\n                    list_of_balls.append(Ball(self.all_sprites))\r\n                    count += 1\r\n                    if count == 33:\r\n                        pygame.time.set_timer(CREATINGBALLS, 0)\r\n                if event.type == FALL:\r\n                    for i in range(len(list_of_balls)):\r\n                        list_of_balls[i].rect.y += 1\r\n                        if list_of_balls[i].rect.y == 310:\r\n                            count_of_fallen_balls += 1\r\n                            list_of_balls[i].kill()\r\n                            list_of_balls.remove(list_of_balls[i])\r\n                            if count_of_fallen_balls == 1:\r\n                                self.hard3.kill()\r\n                            if count_of_fallen_balls == 2:\r\n                                self.hard2.kill()\r\n                            if count_of_fallen_balls == 3:\r\n                                self.hard1.kill()\r\n                            break\r\n                        if list_of_balls[i].rect.center[1] in range(270, 310) and \\\r\n                                list_of_balls[i].rect.center[0] in range(self.basket.rect.x, self.basket.rect.x + 100):\r\n                            list_of_balls[i].kill()\r\n                            count_of_catched_balls += 1\r\n                            list_of_balls.remove(list_of_balls[i])\r\n                            break\r\n                if count == 1:\r\n                    pygame.time.set_timer(FALL, 4)\r\n            keys = pygame.key.get_pressed()\r\n            if keys[pygame.K_LEFT]:\r\n                if self.basket.rect.x > 145:\r\n                    self.basket.rect.x -= 1\r\n                    clock.tick(300)\r\n            if keys[pygame.K_RIGHT]:\r\n                if self.basket.rect.x < 435:\r\n                    self.basket.rect.x += 1\r\n                    clock.tick(300)\r\n            pygame.draw.rect(self.screen, (255, 255, 255), (150, 0, 350, 350))\r\n            pygame.draw.rect(self.screen, (200, 170, 100), (150, 300, 350, 60))\r\n            font = pygame.font.Font(None, 30)\r\n            text = font.render(\"Поймайте 30 шариков!\", True, (0, 0, 0))\r\n            text_x = 155\r\n            text_y = 10\r\n            self.screen.blit(text, (text_x, text_y))\r\n\r\n            stroka = f'Вы поймали {count_of_catched_balls}/30'\r\n            text2 = font.render(stroka, True, (0, 0, 0))\r\n            text2_x = 155\r\n            text2_y = 35\r\n            self.screen.blit(text2, (text2_x, text2_y))\r\n            self.all_sprites.draw(self.screen)\r\n            # clock.tick(fps)\r\n            pygame.display.flip()\r\n\r\n            if count_of_fallen_balls >= 3:\r\n                return False\r\n            if count_of_catched_balls == 30:\r\n                return True\r\n        pygame.quit()\r\n\r\n\r\nclass SearchEmoji(Board):  # класс мини-игры SearchEmoji\r\n    def __init__(self, screen, v=None):\r\n        global flag_minigames1, flag_minigames2, flag_minigames3, room, flag_minigames2_2\r\n\r\n        # на экран выводятся все надписи\r\n        self.screen = screen\r\n        pygame.draw.rect(screen, (100, 100, 100), (150, 0, 350, 350))\r\n        self.n = randrange(1, 31)\r\n        self.desired_emoji = load_image(f'emoji{self.n}.png')\r\n        screen.blit(self.desired_emoji, (250, 6))\r\n        self.desired_emoji_coords = (randrange(10), randrange(10))\r\n        super().__init__(screen)\r\n        font = pygame.font.Font(None, 30)\r\n        text = font.render(\"Найдите:\", True, (0, 0, 0))\r\n        text_x = 155\r\n        text_y = 10\r\n        screen.blit(text, (text_x, text_y))\r\n        self.time = 19\r\n        text2 = font.render(str(self.time), True, (0, 0, 0))\r\n        text2_x = 380\r\n        text2_y = 10\r\n        screen.blit(text2, (text2_x, text2_y))\r\n\r\n        self.all_sprites = pygame.sprite.Group()\r\n\r\n        # создаются спрайты показывающие количество \"жизней\"\r\n        self.hard1 = pygame.sprite.Sprite()\r\n        self.hard1.image = load_image(\"health.png\")\r\n        self.hard1.rect = self.hard1.image.get_rect()\r\n        self.all_sprites.add(self.hard1)\r\n\r\n        self.hard1.rect.x = 465\r\n        self.hard1.rect.y = 6\r\n\r\n        self.hard2 = pygame.sprite.Sprite()\r\n        self.hard2.image = load_image(\"health.png\")\r\n        self.hard2.rect = self.hard2.image.get_rect()\r\n        self.all_sprites.add(self.hard2)\r\n\r\n        self.hard2.rect.x = 435\r\n        self.hard2.rect.y = 6\r\n\r\n        self.hard3 = pygame.sprite.Sprite()\r\n        self.hard3.image = load_image(\"health.png\")\r\n        self.hard3.rect = self.hard3.image.get_rect()\r\n        self.all_sprites.add(self.hard3)\r\n\r\n        self.hard3.rect.x = 405\r\n        self.hard3.rect.y = 6\r\n\r\n        self.all_sprites.draw(screen)\r\n\r\n        if self.playing():  # запускается игровой цикл мини-игры и проверяется выиграл пользователь или проиграл\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы победили!!!\", True, (100, 255, 100))  # при победе выводиться зеленая надпись 'Вы победили!!!'\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n            if room == 1:  # при победе проверяется в какой комнате была вызвана мини-игра и меняет флаг на True\r\n                flag_minigames1 = True\r\n            elif room == 2 and v == 0:  # переменная v - необязательная\r\n                flag_minigames2 = True  # она нужна для различия двух мини-игр в одной комнате\r\n            elif room == 2 and v == 1:\r\n                flag_minigames2_2 = True\r\n            elif room == 3:\r\n                flag_minigames3 = True\r\n            running3()  # запускает основной цикл\r\n\r\n        else:\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы проиграли!!!\", True, (255, 0, 0))\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n            minigames.append(1)  # при проигрыше возвращает мини-игру в список и запускает главный цикл\r\n            running3()\r\n\r\n\r\n    def playing(self):\r\n        running = True\r\n\r\n        # создается событие время истекло и запускается таймер\r\n        TIMERUNOUT = pygame.USEREVENT + 1\r\n        pygame.time.set_timer(TIMERUNOUT, 20000)\r\n\r\n        # создается событие изменяющее оставшееся время на экране\r\n        TIMER = pygame.USEREVENT + 2\r\n        pygame.time.set_timer(TIMER, 1000)\r\n\r\n        a = 'playing'\r\n        count_of_wrong_click = 0\r\n\r\n        while running:\r\n            self.screen.fill((0, 0, 0))\r\n            for event in pygame.event.get():\r\n                if event.type == pygame.QUIT:\r\n                    running = False\r\n                if event.type == pygame.MOUSEBUTTONDOWN:\r\n                    if self.get_click(event.pos): # проверка нажатия пользователя\r\n                        a = 'win'\r\n                    else:\r\n                        # за неверный ответ отнимаетя одна \"жизнь\"\r\n                        count_of_wrong_click += 1\r\n                        if count_of_wrong_click == 1:\r\n                            self.hard3.kill()\r\n                        if count_of_wrong_click == 2:\r\n                            self.hard2.kill()\r\n                        if count_of_wrong_click == 3:\r\n                            self.hard1.kill()\r\n                if event.type == TIMERUNOUT: # проверка на истечение времени\r\n                    a = 'defeat'\r\n                if event.type == TIMER:\r\n                    # уменьшение оставшегося времени выведенного на экране\r\n                    self.time -= 1\r\n            if a == 'win':\r\n                # при победе возврвщается True\r\n                return True\r\n            if a == 'defeat' or count_of_wrong_click >= 3:\r\n                # при поражерии возвращается False\r\n                return False\r\n\r\n            # всё рисуется на экране\r\n            pygame.draw.rect(self.screen, (100, 100, 100), (150, 0, 350, 350))\r\n            self.screen.blit(self.desired_emoji, (250, 6))\r\n            font = pygame.font.Font(None, 30)\r\n            text = font.render(\"Найдите:\", True, (0, 0, 0))\r\n            text_x = 155\r\n            text_y = 10\r\n            self.screen.blit(text, (text_x, text_y))\r\n            text2 = font.render(str(self.time), True, (0, 0, 0))\r\n            text2_x = 380\r\n            text2_y = 10\r\n            self.screen.blit(text2, (text2_x, text2_y))\r\n            self.render(self.screen)\r\n            self.all_sprites.draw(self.screen)\r\n            pygame.display.flip()\r\n        pygame.quit()\r\n\r\n    def render(self, screen): # функция отвечает за рисование всех смайликов на экране\r\n        for y in range(self.height):\r\n            for x in range(self.width):\r\n                if self.board[x][y] == 0: # клетка поля еще не заполнена\r\n                    if (x, y) == self.desired_emoji_coords: # координаты совпадают с координатами искомого смайлика\r\n                        # присвоение клетке номера смайлика и рисование смайлика на экране\r\n                        self.board[x][y] = self.n\r\n                        self.screen.blit(self.desired_emoji,\r\n                                         (x * self.cell_size + self.left, y * self.cell_size + self.top,\r\n                                          self.cell_size, self.cell_size))\r\n                    else:\r\n                        # выбор случайного смайлика и его рисование на экране, присвоение клетке его ноиера\r\n                        n = randrange(1, 31)\r\n                        while n == self.n:\r\n                            n = randrange(1, 31)\r\n                        emoji = load_image(f'emoji{n}.png')\r\n                        self.board[x][y] = n\r\n                        self.screen.blit(emoji, (x * self.cell_size + self.left, y * self.cell_size + self.top,\r\n                                                 self.cell_size, self.cell_size))\r\n                else:\r\n                    # рисование смайлика на экране\r\n                    emoji = load_image(f'emoji{self.board[x][y]}.png')\r\n                    self.screen.blit(emoji, (x * self.cell_size + self.left, y * self.cell_size + self.top,\r\n                                             self.cell_size, self.cell_size))\r\n\r\n    def on_click(self, cell):\r\n        # проверка на правильный ответ и возвращение True/False\r\n        if cell == self.desired_emoji_coords:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\nclass SearchCouples(Board): # класс мини игры SearchCouples\r\n    def __init__(self, screen, v=None):\r\n        global flag_minigames1, flag_minigames2, flag_minigames3, room, flag_minigames2_2\r\n\r\n        # на экран выводятся все надписи\r\n        self.screen = screen\r\n        pygame.draw.rect(screen, (100, 100, 100), (150, 0, 350, 350))\r\n        self.is_first = True\r\n        self.is_clicked = False\r\n        self.curr_n = None\r\n        self.curr_coords = None\r\n        super().__init__(screen)\r\n        font = pygame.font.Font(None, 30)\r\n        text = font.render(\"Найдите пары\", True, (0, 0, 0))\r\n        text_x = 155\r\n        text_y = 10\r\n        screen.blit(text, (text_x, text_y))\r\n        self.time = 99\r\n        text2 = font.render(str(self.time), True, (0, 0, 0))\r\n        text2_x = 380\r\n        text2_y = 10\r\n        screen.blit(text2, (text2_x, text2_y))\r\n\r\n        # создаются спрайты показывающие количество \"жизней\"\r\n        self.all_sprites = pygame.sprite.Group()\r\n\r\n        self.hard1 = pygame.sprite.Sprite()\r\n        self.hard1.image = load_image(\"health.png\")\r\n        self.hard1.rect = self.hard1.image.get_rect()\r\n        self.all_sprites.add(self.hard1)\r\n\r\n        self.hard1.rect.x = 465\r\n        self.hard1.rect.y = 6\r\n\r\n        self.hard2 = pygame.sprite.Sprite()\r\n        self.hard2.image = load_image(\"health.png\")\r\n        self.hard2.rect = self.hard2.image.get_rect()\r\n        self.all_sprites.add(self.hard2)\r\n\r\n        self.hard2.rect.x = 435\r\n        self.hard2.rect.y = 6\r\n\r\n        self.hard3 = pygame.sprite.Sprite()\r\n        self.hard3.image = load_image(\"health.png\")\r\n        self.hard3.rect = self.hard3.image.get_rect()\r\n        self.all_sprites.add(self.hard3)\r\n\r\n        self.hard3.rect.x = 405\r\n        self.hard3.rect.y = 6\r\n\r\n        self.all_sprites.draw(screen)\r\n\r\n        if self.playing():\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы победили!!!\", True, (100, 255, 100))\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n\r\n            if room == 1:\r\n                flag_minigames1 = True\r\n            elif room == 2 and v == 0:  # переменная v - необязательная\r\n                flag_minigames2 = True  # она нужна для различия двух мини-игр в одной комнате\r\n            elif room == 2 and v == 1:\r\n                flag_minigames2_2 = True\r\n            elif room == 3:\r\n                flag_minigames3 = True\r\n            running3()  # запускает основной цикл\r\n\r\n        else:\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы проиграли!!!\", True, (100, 255, 100))\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n            minigames.append(2)\r\n            running3()\r\n\r\n    def playing(self):\r\n        running = True\r\n        # создается событие время истекло и запускается таймер\r\n        TIMERUNOUT = pygame.USEREVENT + 1\r\n        pygame.time.set_timer(TIMERUNOUT, 20000)\r\n\r\n        # создается событие изменяющее оставшееся время на экране\r\n        TIMER = pygame.USEREVENT + 2\r\n        pygame.time.set_timer(TIMER, 1000)\r\n\r\n        self.count_of_wrong_click = 0\r\n        a = 'playing'\r\n\r\n        while running:\r\n            self.screen.fill((0, 0, 0))\r\n            for event in pygame.event.get():\r\n                if event.type == pygame.QUIT:\r\n                    running = False\r\n                if event.type == pygame.MOUSEBUTTONDOWN:\r\n                    self.get_click(event.pos) # обработка нажатия\r\n\r\n                    # проверка на то, все ли пары найдены\r\n                    check = True\r\n                    for y in range(self.height):\r\n                        for x in range(self.width):\r\n                            if self.board[x][y] != -1:\r\n                                check = False\r\n                                break\r\n                    if check:\r\n                        a = 'win'\r\n                if event.type == TIMERUNOUT: # проверка на истечение времени\r\n                    a = 'defeat'\r\n                if event.type == TIMER:\r\n                    # уменьшение оставшегося времени выведенного на экране\r\n                    self.time -= 1\r\n            if self.count_of_wrong_click == 1:\r\n                self.hard3.kill()\r\n            if self.count_of_wrong_click == 2:\r\n                self.hard2.kill()\r\n            if self.count_of_wrong_click == 3:\r\n                self.hard1.kill()\r\n            if a == 'win':\r\n                # при победе возврвщается True\r\n                return True\r\n            if a == 'defeat' or self.count_of_wrong_click >= 3:\r\n                # при поражерии возвращается False\r\n                return False\r\n\r\n            # всё рисуется на экране\r\n            pygame.draw.rect(self.screen, (100, 100, 100), (150, 0, 350, 350))\r\n            font = pygame.font.Font(None, 30)\r\n            text = font.render(\"Найдите пары\", True, (0, 0, 0))\r\n            text_x = 155\r\n            text_y = 10\r\n            self.screen.blit(text, (text_x, text_y))\r\n            text2 = font.render(str(self.time), True, (0, 0, 0))\r\n            text2_x = 380\r\n            text2_y = 10\r\n            self.screen.blit(text2, (text2_x, text2_y))\r\n            self.render(self.screen)\r\n            self.all_sprites.draw(self.screen)\r\n            pygame.display.flip()\r\n        pygame.quit()\r\n\r\n    def render(self, screen):\r\n        if self.is_first: # в первый запуск функции всем клеткаи поля присваиваются случайные номера смайликов\r\n            self.is_first = False\r\n            for n in range(1, 26):\r\n                for _ in range(4):\r\n                    x, y = randrange(self.width), randrange(self.height)\r\n                    while self.board[x][y] != 0:\r\n                        x, y = randrange(self.width), randrange(self.height)\r\n                    self.board[x][y] = n\r\n                    emoji = load_image(f'emoji{n}.png')\r\n                    self.screen.blit(emoji, (x * self.cell_size + self.left, y * self.cell_size + self.top,\r\n                                             self.cell_size, self.cell_size))\r\n\r\n        if self.is_clicked: # если пользователь нажал на смайлик, появляется обводка\r\n            pygame.draw.rect(screen, pygame.Color('white'), (\r\n                self.curr_coords[0] * self.cell_size + self.left, self.curr_coords[1] * self.cell_size + self.top,\r\n                self.cell_size, self.cell_size))\r\n\r\n        # рисование всех смайликов\r\n        for y in range(self.height):\r\n            for x in range(self.width):\r\n                if self.board[x][y] == -1:\r\n                    continue\r\n                else:\r\n                    emoji = load_image(f'emoji{self.board[x][y]}.png')\r\n                    self.screen.blit(emoji, (x * self.cell_size + self.left, y * self.cell_size + self.top,\r\n                                             self.cell_size, self.cell_size))\r\n\r\n    def on_click(self, cell): # обработка нажатия\r\n        if self.board[cell[0]][cell[1]] == -1: # нажатие на пустую клетку игнорируется\r\n            return\r\n        if self.is_clicked:\r\n            # если пользователь уже нажал на один смайл проверяется насовпадение смайликов\r\n            if cell == self.curr_coords:\r\n                self.is_clicked = False\r\n                self.curr_coords = None\r\n                self.curr_n = None\r\n            else:\r\n                if self.curr_n == self.board[cell[0]][cell[1]]:\r\n                    self.board[cell[0]][cell[1]] = -1\r\n                    self.board[self.curr_coords[0]][self.curr_coords[1]] = -1\r\n                    self.is_clicked = False\r\n                    self.curr_coords = None\r\n                    self.curr_n = None\r\n                else:\r\n                    self.count_of_wrong_click += 1\r\n        else:\r\n            # пользователь ещё не нажимал на смайл, смайл запоминается для последующей проверки\r\n            self.is_clicked = True\r\n            self.curr_coords = cell\r\n            self.curr_n = self.board[cell[0]][cell[1]]\r\n\r\n\r\nclass ConnectingWires:\r\n    def __init__(self, screen, v=None):\r\n        global flag_minigames1, flag_minigames2, flag_minigames3, room, flag_minigames2_2\r\n        self.screen = screen\r\n        pygame.draw.rect(screen, (100, 100, 100), (150, 0, 350, 350))\r\n\r\n        # каждому проводу рандомно присваивается свой цвет\r\n        self.colors = [pygame.Color(\"red\"), pygame.Color(\"orange\"), pygame.Color(\"green\"),\r\n                       pygame.Color(\"blue\"), pygame.Color(\"yellow\"), pygame.Color(\"purple\")]\r\n\r\n        shuffle(self.colors)\r\n        self.left_wires_coords = {\r\n            (150, 60, 60, 20): self.colors[0],\r\n            (150, 110, 60, 20): self.colors[1],\r\n            (150, 160, 60, 20): self.colors[2],\r\n            (150, 210, 60, 20): self.colors[3],\r\n            (150, 260, 60, 20): self.colors[4],\r\n            (150, 310, 60, 20): self.colors[5]\r\n        }\r\n\r\n        shuffle(self.colors)\r\n        self.right_wires_coords = {\r\n            (440, 60, 60, 20): self.colors[0],\r\n            (440, 110, 60, 20): self.colors[1],\r\n            (440, 160, 60, 20): self.colors[2],\r\n            (440, 210, 60, 20): self.colors[3],\r\n            (440, 260, 60, 20): self.colors[4],\r\n            (440, 310, 60, 20): self.colors[5]\r\n        }\r\n\r\n\r\n        font = pygame.font.Font(None, 30)\r\n        text = font.render(\"Найдите:\", True, (0, 0, 0))\r\n        text_x = 155\r\n        text_y = 10\r\n        screen.blit(text, (text_x, text_y))\r\n        self.time = 19\r\n        text2 = font.render(str(self.time), True, (0, 0, 0))\r\n        text2_x = 380\r\n        text2_y = 10\r\n        screen.blit(text2, (text2_x, text2_y))\r\n\r\n        # создаются спрайты показывающие количество \"жизней\"\r\n        self.all_sprites = pygame.sprite.Group()\r\n\r\n        self.hard1 = pygame.sprite.Sprite()\r\n        self.hard1.image = load_image(\"health.png\")\r\n        self.hard1.rect = self.hard1.image.get_rect()\r\n        self.all_sprites.add(self.hard1)\r\n\r\n        self.hard1.rect.x = 465\r\n        self.hard1.rect.y = 6\r\n\r\n        self.hard2 = pygame.sprite.Sprite()\r\n        self.hard2.image = load_image(\"health.png\")\r\n        self.hard2.rect = self.hard2.image.get_rect()\r\n        self.all_sprites.add(self.hard2)\r\n\r\n        self.hard2.rect.x = 435\r\n        self.hard2.rect.y = 6\r\n\r\n        self.hard3 = pygame.sprite.Sprite()\r\n        self.hard3.image = load_image(\"health.png\")\r\n        self.hard3.rect = self.hard3.image.get_rect()\r\n        self.all_sprites.add(self.hard3)\r\n\r\n        self.hard3.rect.x = 405\r\n        self.hard3.rect.y = 6\r\n\r\n        self.all_sprites.draw(screen)\r\n\r\n        if self.playing():\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы победили!!!\", True, (100, 255, 100))\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n            if room == 1:\r\n                flag_minigames1 = True\r\n            elif room == 2 and v == 0:\r\n                flag_minigames2 = True\r\n            elif room == 2 and v == 1:\r\n                flag_minigames2_2 = True\r\n            elif room == 3:\r\n                flag_minigames3 = True\r\n            running3()\r\n        else:\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы проиграли!!!\", True, (255, 0, 0))\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n            minigames.append(3)\r\n            running3()\r\n\r\n    def get_color(self, pos):\r\n        # возвращение цвета выбранного провода\r\n        x, y = pos\r\n        if y in range(60, 81):\r\n            if x in range(150, 210):\r\n                return self.left_wires_coords[(150, 60, 60, 20)]\r\n            elif x in range(440, 500):\r\n                return self.right_wires_coords[(440, 60, 60, 20)]\r\n        elif y in range(110, 131):\r\n            if x in range(150, 210):\r\n                return self.left_wires_coords[(150, 110, 60, 20)]\r\n            elif x in range(440, 500):\r\n                return self.right_wires_coords[(440, 110, 60, 20)]\r\n        elif y in range(160, 181):\r\n            if x in range(150, 210):\r\n                return self.left_wires_coords[(150, 160, 60, 20)]\r\n            elif x in range(440, 500):\r\n                return self.right_wires_coords[(440, 160, 60, 20)]\r\n        elif y in range(210, 231):\r\n            if x in range(150, 210):\r\n                return self.left_wires_coords[(150, 210, 60, 20)]\r\n            elif x in range(440, 500):\r\n                return self.right_wires_coords[(440, 210, 60, 20)]\r\n        elif y in range(260, 281):\r\n            if x in range(150, 210):\r\n                return self.left_wires_coords[(150, 260, 60, 20)]\r\n            elif x in range(440, 500):\r\n                return self.right_wires_coords[(440, 260, 60, 20)]\r\n        elif y in range(310, 331):\r\n            if x in range(150, 210):\r\n                return self.left_wires_coords[(150, 310, 60, 20)]\r\n            elif x in range(440, 500):\r\n                return self.right_wires_coords[(440, 310, 60, 20)]\r\n        return False\r\n\r\n    def get_coords(self, pos):\r\n        # возвращение координат провода\r\n        x, y = pos\r\n        if y in range(60, 81):\r\n            if x in range(150, 210):\r\n                return (150, 60, 60, 20)\r\n            elif x in range(440, 500):\r\n                return (440, 60, 60, 20)\r\n        elif y in range(110, 131):\r\n            if x in range(150, 210):\r\n                return (150, 110, 60, 20)\r\n            elif x in range(440, 500):\r\n                return (440, 110, 60, 20)\r\n        elif y in range(160, 181):\r\n            if x in range(150, 210):\r\n                return (150, 160, 60, 20)\r\n            elif x in range(440, 500):\r\n                return (440, 160, 60, 20)\r\n        elif y in range(210, 231):\r\n            if x in range(150, 210):\r\n                return (150, 210, 60, 20)\r\n            elif x in range(440, 500):\r\n                return (440, 210, 60, 20)\r\n        elif y in range(260, 281):\r\n            if x in range(150, 210):\r\n                return (150, 260, 60, 20)\r\n            elif x in range(440, 500):\r\n                return (440, 260, 60, 20)\r\n        elif y in range(310, 331):\r\n            if x in range(150, 210):\r\n                return (150, 310, 60, 20)\r\n            elif x in range(440, 500):\r\n                return (440, 310, 60, 20)\r\n        return False\r\n\r\n    def playing(self):\r\n        running = True\r\n\r\n        # создается событие время истекло и запускается таймер\r\n        TIMERUNOUT = pygame.USEREVENT + 1\r\n        pygame.time.set_timer(TIMERUNOUT, 20000)\r\n\r\n        # создается событие изменяющее оставшееся время на экране\r\n        TIMER = pygame.USEREVENT + 2\r\n        pygame.time.set_timer(TIMER, 1000)\r\n\r\n        a = 'playing'\r\n        click = False\r\n        color = None\r\n        count_of_wrong_click = 0\r\n        count_of_connected_wires = 0\r\n        starts_and_ends = [] # список начал, концов, цветов соединенный прводов; нужен для рисования на экране\r\n\r\n        while running:\r\n            screen.fill((0, 0, 0))\r\n            for event in pygame.event.get():\r\n                if event.type == pygame.QUIT:\r\n                    running = False\r\n                if event.type == pygame.MOUSEBUTTONDOWN:\r\n                    if click: # когда провод уже выбран, проверяется на совпадение цветв пары\r\n                        if self.get_color(event.pos) == color:\r\n                            click = False\r\n                            if coords_for_rect == self.get_coords(event.pos):\r\n                                pass\r\n                            else:\r\n                                count_of_connected_wires += 1\r\n                                if coords_for_rect[0] < self.get_coords(event.pos)[0]:\r\n                                    b = ((210, coords_for_rect[1] + 9), (440, self.get_coords(event.pos)[1] + 9),\r\n                                         self.get_color(event.pos))\r\n                                    starts_and_ends.append(b)\r\n                                else:\r\n                                    b = ((210, self.get_coords(event.pos)[1] + 9), (440, coords_for_rect[1] + 9),\r\n                                         self.get_color(event.pos))\r\n                                    starts_and_ends.append(b)\r\n                        else:\r\n                            count_of_wrong_click += 1\r\n                            if count_of_wrong_click == 1:\r\n                                self.hard3.kill()\r\n                            if count_of_wrong_click == 2:\r\n                                self.hard2.kill()\r\n                            if count_of_wrong_click == 3:\r\n                                self.hard1.kill()\r\n                    else: # провод на который нажили запоминается\r\n                        click = True\r\n                        coords_for_rect = self.get_coords(event.pos)\r\n                        color = self.get_color(event.pos)\r\n                if event.type == TIMERUNOUT:\r\n                    a = 'defeat'\r\n                if event.type == TIMER:\r\n                    self.time -= 1\r\n            self.screen.fill((0, 0, 0))\r\n            pygame.draw.rect(self.screen, (100, 100, 100), (150, 0, 350, 350))\r\n            for coords in self.left_wires_coords.keys():\r\n                pygame.draw.rect(self.screen, self.left_wires_coords[coords], coords)\r\n            for coords in self.right_wires_coords.keys():\r\n                pygame.draw.rect(self.screen, self.right_wires_coords[coords], coords)\r\n            if click:\r\n                pygame.draw.rect(self.screen, pygame.Color('white'), coords_for_rect, 2)\r\n            for elem in starts_and_ends:\r\n                if elem[0][1] == 69 and elem[1][1] == 319:\r\n                    pygame.draw.line(self.screen, elem[2],\r\n                                     (elem[0][0], elem[0][1] - 9), (elem[1][0], elem[1][1] + 10), width=30)\r\n                elif elem[0][1] == 319 and elem[1][1] == 69:\r\n                    pygame.draw.line(self.screen, elem[2],\r\n                                     (elem[0][0], elem[0][1] + 10), (elem[1][0], elem[1][1] - 9), width=30)\r\n                else:\r\n                    pygame.draw.line(self.screen, elem[2], elem[0], elem[1], width=20)\r\n            font = pygame.font.Font(None, 30)\r\n            text = font.render(\"Соедините\", True, (0, 0, 0))\r\n            text_x = 155\r\n            text_y = 8\r\n            self.screen.blit(text, (text_x, text_y))\r\n            text1 = font.render(\"соответствующие цвета\", True, (0, 0, 0))\r\n            text_x1 = 155\r\n            text_y1 = 30\r\n            self.screen.blit(text1, (text_x1, text_y1))\r\n            text2 = font.render(str(self.time), True, (0, 0, 0))\r\n            text2_x = 470\r\n            text2_y = 32\r\n            self.screen.blit(text2, (text2_x, text2_y))\r\n            self.all_sprites.draw(self.screen)\r\n            if count_of_connected_wires == 6:\r\n                return True\r\n            if a == 'defeat' or count_of_wrong_click >= 3:\r\n                return False\r\n            pygame.display.flip()\r\n        pygame.quit()\r\n\r\n\r\nclass Summas(Board):\r\n    def __init__(self, screen, v=None):\r\n        global flag_minigames1, flag_minigames2, flag_minigames3, room, flag_minigames2_2\r\n        self.screen = screen\r\n        pygame.draw.rect(screen, (100, 100, 100), (150, 0, 350, 350))\r\n        self.is_first = True\r\n        self.is_clicked = False\r\n        self.curr_n = None\r\n        self.curr_coords = None\r\n        super().__init__(screen)\r\n\r\n        # вывод всех надписей на экран\r\n        font = pygame.font.Font(None, 20)\r\n        text = font.render(\"Найдите пары чисел,\", True, (0, 0, 0))\r\n        text_x = 155\r\n        text_y = 6\r\n        screen.blit(text, (text_x, text_y))\r\n        text1 = font.render(\"где сума равна 101\", True, (0, 0, 0))\r\n        text_x1 = 155\r\n        text_y1 = 10\r\n        screen.blit(text1, (text_x1, text_y1))\r\n        self.time = 499\r\n        text2 = font.render(str(self.time), True, (0, 0, 0))\r\n        text2_x = 380\r\n        text2_y = 10\r\n        screen.blit(text2, (text2_x, text2_y))\r\n\r\n        # создаются спрайты показывающие количество \"жизней\"\r\n        self.all_sprites = pygame.sprite.Group()\r\n\r\n        self.hard1 = pygame.sprite.Sprite()\r\n        self.hard1.image = load_image(\"health.png\")\r\n        self.hard1.rect = self.hard1.image.get_rect()\r\n        self.all_sprites.add(self.hard1)\r\n\r\n        self.hard1.rect.x = 465\r\n        self.hard1.rect.y = 6\r\n\r\n        self.hard2 = pygame.sprite.Sprite()\r\n        self.hard2.image = load_image(\"health.png\")\r\n        self.hard2.rect = self.hard2.image.get_rect()\r\n        self.all_sprites.add(self.hard2)\r\n\r\n        self.hard2.rect.x = 435\r\n        self.hard2.rect.y = 6\r\n\r\n        self.hard3 = pygame.sprite.Sprite()\r\n        self.hard3.image = load_image(\"health.png\")\r\n        self.hard3.rect = self.hard3.image.get_rect()\r\n        self.all_sprites.add(self.hard3)\r\n\r\n        self.hard3.rect.x = 405\r\n        self.hard3.rect.y = 6\r\n\r\n        self.all_sprites.draw(screen)\r\n\r\n        if self.playing():\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы победили!!!\", True, (100, 255, 100))\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n\r\n            if room == 1:\r\n                flag_minigames1 = True\r\n            elif room == 2 and v == 0:\r\n                flag_minigames2 = True\r\n            elif room == 2 and v == 1:\r\n                flag_minigames2_2 = True\r\n            elif room == 3:\r\n                flag_minigames3 = True\r\n            running3()\r\n        else:\r\n            font = pygame.font.Font(None, 40)\r\n            text = font.render(\"Вы проиграли!!!\", True, (100, 255, 100))\r\n            text_x = 210\r\n            text_y = 150\r\n            text_w = text.get_width()\r\n            text_h = text.get_height()\r\n            pygame.draw.rect(screen, (0, 0, 0), (text_x - 10, text_y - 10,\r\n                                                 text_w + 20, text_h + 20))\r\n            screen.blit(text, (text_x, text_y))\r\n            minigames.append(0)\r\n            running3()\r\n\r\n    def playing(self):\r\n        running = True\r\n\r\n        # создается событие время истекло и запускается таймер\r\n        TIMERUNOUT = pygame.USEREVENT + 1\r\n        pygame.time.set_timer(TIMERUNOUT, 20000)\r\n\r\n        # создается событие изменяющее оставшееся время на экране\r\n        TIMER = pygame.USEREVENT + 2\r\n        pygame.time.set_timer(TIMER, 1000)\r\n\r\n        self.count_of_wrong_click = 0\r\n\r\n        a = 'playing'\r\n\r\n        while running:\r\n            # аналогично мини-игре SearchCouples, только вместо пар смайликов пары чисел\r\n            self.screen.fill((0, 0, 0))\r\n            for event in pygame.event.get():\r\n                if event.type == pygame.QUIT:\r\n                    running = False\r\n                if event.type == pygame.MOUSEBUTTONDOWN:\r\n                    self.get_click(event.pos)\r\n                    check = True\r\n                    for y in range(self.height):\r\n                        for x in range(self.width):\r\n                            if self.board[x][y] != -1:\r\n                                check = False\r\n                                break\r\n                    if check:\r\n                        a = 'win'\r\n                if event.type == TIMERUNOUT:\r\n                    a = 'defeat'\r\n                if event.type == TIMER:\r\n                    self.time -= 1\r\n            if self.count_of_wrong_click == 1:\r\n                self.hard3.kill()\r\n            if self.count_of_wrong_click == 2:\r\n                self.hard2.kill()\r\n            if self.count_of_wrong_click == 3:\r\n                self.hard1.kill()\r\n            if a == 'win':\r\n                return True\r\n            if a == 'defeat' or self.count_of_wrong_click >= 3:\r\n                return False\r\n            pygame.draw.rect(self.screen, (100, 100, 100), (150, 0, 350, 350))\r\n            font = pygame.font.Font(None, 25)\r\n            text = font.render(\"Найдите пары чисел,\", True, (0, 0, 0))\r\n            text_x = 155\r\n            text_y = 6\r\n            self.screen.blit(text, (text_x, text_y))\r\n            text1 = font.render(\"где сума равна 101\", True, (0, 0, 0))\r\n            text_x1 = 155\r\n            text_y1 = 21\r\n            self.screen.blit(text1, (text_x1, text_y1))\r\n            text2 = font.render(str(self.time), True, (0, 0, 0))\r\n            text2_x = 380\r\n            text2_y = 10\r\n            self.screen.blit(text2, (text2_x, text2_y))\r\n            self.render(self.screen)\r\n            self.all_sprites.draw(self.screen)\r\n            pygame.display.flip()\r\n        pygame.quit()\r\n\r\n    def render(self, screen):\r\n        if self.is_first: # в первый запуск функции всем клеткам присваиваются свои числа\r\n            self.is_first = False\r\n            numbers = list(range(1, 101))\r\n            for y in range(self.height):\r\n                for x in range(self.width):\r\n                    n = numbers.index(choice(numbers))\r\n                    self.board[x][y] = numbers.pop(n)\r\n\r\n        if self.is_clicked: # выбранная клетка выделяется белым\r\n            pygame.draw.rect(screen, pygame.Color('white'), (\r\n                self.curr_coords[0] * self.cell_size + self.left, self.curr_coords[1] * self.cell_size + self.top,\r\n                self.cell_size, self.cell_size))\r\n\r\n        # рисование чисел и поля на экране\r\n        for y in range(self.height):\r\n            for x in range(self.width):\r\n                if self.board[x][y] == -1:\r\n                    continue\r\n                else:\r\n                    pygame.draw.rect(screen, pygame.Color(\"white\"), (\r\n                        x * self.cell_size + self.left, y * self.cell_size + self.top, self.cell_size,\r\n                        self.cell_size), 1)\r\n                    font = pygame.font.Font(None, 25)\r\n                    text = font.render(str(self.board[x][y]), True, (0, 0, 0))\r\n                    if self.board[x][y] == 100:\r\n                        text_x = x * self.cell_size + self.left + 1\r\n                    elif self.board[x][y] < 10:\r\n                        text_x = x * self.cell_size + self.left + 12\r\n                    else:\r\n                        text_x = x * self.cell_size + self.left + 6\r\n                    text_y = y * self.cell_size + self.top + 6\r\n                    self.screen.blit(text, (text_x, text_y))\r\n\r\n    def on_click(self, cell):\r\n        # обработка нажатия аналогична мини-игре SearchCouples, только проверяется сумма выбранных чисел\r\n        if self.board[cell[0]][cell[1]] == -1:\r\n            return\r\n        if self.is_clicked:\r\n            if cell == self.curr_coords:\r\n                self.is_clicked = False\r\n                self.curr_coords = None\r\n                self.curr_n = None\r\n            else:\r\n                if self.curr_n + self.board[cell[0]][cell[1]] == 101:\r\n                    self.board[cell[0]][cell[1]] = -1\r\n                    self.board[self.curr_coords[0]][self.curr_coords[1]] = -1\r\n                    self.is_clicked = False\r\n                    self.curr_coords = None\r\n                    self.curr_n = None\r\n                else:\r\n                    self.count_of_wrong_click += 1\r\n        else:\r\n            self.is_clicked = True\r\n            self.curr_coords = cell\r\n            self.curr_n = self.board[cell[0]][cell[1]]\r\n\r\n\r\nminigames = [0, 1, 2, 3]  # список с числом мини-игр\r\n\r\n\r\ndef running(screen, v=None):  # функция, отвечающая за перемешивания списка и запуска мини-игр\r\n    global minigames\r\n    pygame.display.set_caption('Игра')  # меняем заголовок окна\r\n    shuffle(minigames)  # меняем последовательность в списке\r\n    a = minigames.pop()  # берем элемент из списка, одновременно удалем число\r\n    # a = 1  # не забыть удалить!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n    if a == 0:  # вызываем игру в зависимости от числа\r\n        Summas(screen, v)\r\n    elif a == 1:\r\n        SearchEmoji(screen, v)\r\n    elif a == 2:\r\n        SearchCouples(screen, v)\r\n    elif a == 3:\r\n        ConnectingWires(screen, v)\r\n\r\n#########################################\r\n\r\n\r\nclass Thing(pygame.sprite.Sprite):  # специальный класс, для всех спрайтов в комнатах и лобби\r\n    def __init__(self, number):  # при инициализации спрайта передаем число, по нему у спрайта ставиться нужная каринка\r\n        super(Thing, self).__init__()  # и задаются координаты\r\n        self.number = number\r\n        if number == 1:\r\n            self.image = thing1\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x = 226\r\n            self.rect.y = 116\r\n        elif number == 2:\r\n            self.image = thing2\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x = 306\r\n            self.rect.y = 149\r\n        elif number == 3:\r\n            self.image = thing3\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x = 315\r\n            self.rect.y = 163\r\n        elif number == 4:\r\n            self.image = thing2_2\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x = 469\r\n            self.rect.y = 232\r\n        elif number == 5:\r\n            self.image = bg0_butt1\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x = 421\r\n            self.rect.y = 135\r\n        elif number == 6:\r\n            self.image = bg0_butt2\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x = 421\r\n            self.rect.y = 176\r\n        elif number == 7:\r\n            self.image = bg0_butt3\r\n            self.rect = self.image.get_rect()\r\n            self.rect.x = 0\r\n            self.rect.y = 0\r\n\r\n    def update(self, *args):  # метод update нужен для реализации нажатия на спрайт\r\n        if self.number == 1:\r\n            if args and args[0].type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(\r\n                    args[0].pos) and 215 < person.rect.x < 300 and room == 1:\r\n                running(screen)\r\n        elif self.number == 2:\r\n            if args and args[0].type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(\r\n                    args[0].pos) and 215 < person.rect.x < 340 and room == 2:\r\n                running(screen, 0)\r\n        elif self.number == 3:\r\n            if args and args[0].type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(\r\n                    args[0].pos) and 300 < person.rect.x < 350 and room == 3:\r\n                running(screen)\r\n        elif self.number == 4:\r\n            if args and args[0].type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(\r\n                    args[0].pos) and 430 < person.rect.x < 500 and room == 2:\r\n                running(screen, 1)\r\n        elif self.number == 5:\r\n            if args and args[0].type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(\r\n                    args[0].pos):\r\n                running3()\r\n        elif self.number == 6:\r\n            if args and args[0].type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(\r\n                    args[0].pos):\r\n                running4()\r\n        elif self.number == 7:\r\n            if args and args[0].type == pygame.MOUSEBUTTONDOWN and self.rect.collidepoint(\r\n                    args[0].pos):\r\n                running2()\r\n\r\n\r\ncup = Thing(1)  # создаем спрайты для комнат и групппы спрайтов\r\ntv = Thing(2)\r\nmicro = Thing(3)\r\nvalli = Thing(4)\r\nbutt1 = Thing(5)\r\nbutt2 = Thing(6)\r\nbutt3 = Thing(7)\r\nall_sprites_room1 = pygame.sprite.Group()\r\nall_sprites_room2 = pygame.sprite.Group()\r\nall_sprites_room3 = pygame.sprite.Group()\r\nall_sprites_screen1 = pygame.sprite.Group()\r\nall_sprites_screen2 = pygame.sprite.Group()\r\nall_sprites_room1.add(cup, person)\r\nall_sprites_room2.add(tv, valli, person)\r\nall_sprites_room3.add(micro, person)\r\nall_sprites_screen1.add(butt1, butt2)\r\nall_sprites_screen2.add(butt3)\r\n\r\nroom = 1  # переменна отвечающая за комнату, с которой начинается игра\r\n\r\n\r\ndef running3():  # функция running3 - основной цикл игры\r\n    global room, flag_minigames1, flag_minigames2, flag_minigames2_2, flag_minigames3, minigames\r\n    pygame.init()\r\n    running2 = True\r\n    while running2:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running2 = False\r\n            if room == 1:  # выбор фона, названия окна\r\n                pygame.display.set_caption('room1')\r\n                screen.blit(bg, (0, 0))\r\n                if flag_minigames1 is True:  # флаг мини-игры, если True, то удаляется спрайт\r\n                    all_sprites_room1.remove(cup)\r\n                all_sprites_room1.draw(screen)\r\n                all_sprites_room1.update(event)\r\n            elif room == 2:\r\n                pygame.display.set_caption('room2')\r\n                screen.blit(bg2, (0, 0))\r\n                if flag_minigames2 is True:\r\n                    all_sprites_room2.remove(tv)\r\n                if flag_minigames2_2 is True:\r\n                    all_sprites_room2.remove(valli)\r\n                all_sprites_room2.draw(screen)\r\n                all_sprites_room2.update(event)\r\n            elif room == 3:\r\n                pygame.display.set_caption('room3')\r\n                screen.blit(bg3, (0, 0))\r\n                if flag_minigames3 is True:\r\n                    all_sprites_room3.remove(micro)\r\n                all_sprites_room3.draw(screen)\r\n                all_sprites_room3.update(event)\r\n            if event.type == pygame.KEYDOWN:  # обработка нажатия клавиш\r\n                if room == 1 and event.key == 101 and person.rect.x >= 515 and flag_minigames1 is True:  # переход между комнатами\r\n                    room = 2\r\n                    person.rect.x = 0\r\n                elif room == 2 and event.key == 101 and person.rect.x <= 115:\r\n                    room = 1\r\n                    person.rect.x = 515\r\n                elif flag_minigames2 and event.key == 101 and person.rect.x >= 515 and flag_minigames2_2 and room == 2:\r\n                    room = 3\r\n                    person.rect.x = 0\r\n                elif room == 3 and event.key == 101 and person.rect.x <= 115:\r\n                    room = 2\r\n                    person.rect.x = 515\r\n                elif flag_minigames3 and event.key == 101 and person.rect.x >= 515 and room == 3:  # конечная заставка\r\n                    room = 1  # возвращаю начальные переменные для начала новой игры\r\n                    person.rect.x = 0\r\n                    all_sprites_room1.clear()\r\n                    all_sprites_room2.clear()\r\n                    all_sprites_room3.clear()\r\n                    all_sprites_room1.add(cup, person)\r\n                    all_sprites_room2.add(tv, valli, person)\r\n                    all_sprites_room3.add(micro, person)\r\n                    all_sprites_screen1.add(butt1, butt2)\r\n                    all_sprites_screen2.add(butt3)\r\n                    flag_minigames3 = False\r\n                    flag_minigames2 = False\r\n                    flag_minigames2_2 = False\r\n                    flag_minigames1 = False\r\n                    minigames = [0, 1, 2, 3]\r\n                    running5()\r\n            clock.tick(fps)  # обработка внутриигрового времени\r\n            keys = pygame.key.get_pressed()  # реализация ходьбы персонажа зажатием клавиши\r\n            if keys[pygame.K_LEFT] or keys[pygame.K_a]:\r\n                if person.rect.x != 0:\r\n                    person.rect.x -= speed\r\n                person.image = pers(flag, 'l')\r\n            if keys[pygame.K_RIGHT] or keys[pygame.K_d]:\r\n                if person.rect.x + 78 <= w:\r\n                    person.rect.x += speed\r\n                person.image = pers(flag, 'r')\r\n            if room == 1:  # реализация диалогового окна внизу экрана\r\n                screen.blit(bg, (0, 0))\r\n                all_sprites_room1.draw(screen)\r\n                pygame.draw.rect(screen, (255, 255, 255), (8, 308, 635, 35))\r\n                if flag_minigames1 is True:  # текст меняется по прохождению мини-игр\r\n                    stroka = 'Мой дорогой кубок. Сколько воспоминаний нахлынуло... Я получил его на соревнованиях по пляжному волейболу.'\r\n                    font = pygame.font.Font(None, 15)\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 310\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Сразу лето вспомнилось. Тепло... Хочу под одеяло! Всё бы отдал, чтобы сейчас обратно лечь спать.'\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 320\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Но всё-таки надо собираться в школу!'\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 330\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Подсказка: \"Пройдите в следующую комнату. Подойдите к двери и нажмите E\"'\r\n                    text = font.render(stroka, True, (80, 80, 80))\r\n                    text_x = 220\r\n                    text_y = 330\r\n                    screen.blit(text, (text_x, text_y))\r\n                else:\r\n                    stroka = 'Я проснулся от звука будильника. Как обычно хочется спать. В комнате как-то холодно.' \\\r\n                             ' Вот бы обратно под одеяло лечь.'\r\n                    font = pygame.font.Font(None, 15)\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 310\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Мне снился странный сон. ' \\\r\n                             'Там я потерял свой кубок и спрашивал у всех людей на улице, не видели ли они его.'\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 320\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Кстати где кубок сейчас?'\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 330\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Подсказка: \"Найдите кубок. Подойдите к нему и нажмите\"'\r\n                    text = font.render(stroka, True, (80, 80, 80))\r\n                    text_x = 320\r\n                    text_y = 330\r\n                    screen.blit(text, (text_x, text_y))\r\n            elif room == 2:\r\n                screen.blit(bg2, (0, 0))\r\n                all_sprites_room2.draw(screen)\r\n                pygame.draw.rect(screen, (255, 255, 255), (8, 308, 635, 35))\r\n                if flag_minigames2 is True:\r\n                    if flag_minigames2_2 is True:\r\n                        stroka = '*Урчание живота*'\r\n                        font = pygame.font.Font(None, 15)\r\n                        text = font.render(stroka, True, (0, 0, 0))\r\n                        text_x = 10\r\n                        text_y = 310\r\n                        screen.blit(text, (text_x, text_y))\r\n                        stroka = 'Я, кажется, совершенно забыл о том, что мне в школу надо собираться . Пойду завтракать.'\r\n                        text = font.render(stroka, True, (0, 0, 0))\r\n                        text_x = 10\r\n                        text_y = 320\r\n                        screen.blit(text, (text_x, text_y))\r\n                        stroka = 'Подсказка: \"Пройдите в следующую комнату. Подойдите к двери и нажмите E'\r\n                        text = font.render(stroka, True, (80, 80, 80))\r\n                        text_x = 10\r\n                        text_y = 330\r\n                        screen.blit(text, (text_x, text_y))\r\n                    else:\r\n                        stroka = 'Новости: ~Сегодня в Москве аномальный снегопад. Ночью выпала месячная норма осадков.~'\r\n                        font = pygame.font.Font(None, 15)\r\n                        text = font.render(stroka, True, (0, 0, 0))\r\n                        text_x = 10\r\n                        text_y = 310\r\n                        screen.blit(text, (text_x, text_y))\r\n                        stroka = 'Много снега это классно, но точно не для ЖКХ. Может с друзьями снеговика слепить? Мой робот Валли совершенно.'\r\n                        text = font.render(stroka, True, (0, 0, 0))\r\n                        text_x = 10\r\n                        text_y = 320\r\n                        screen.blit(text, (text_x, text_y))\r\n                        stroka = 'зыпылился. Пожалуй надо стереть пыть.'\r\n                        text = font.render(stroka, True, (0, 0, 0))\r\n                        text_x = 10\r\n                        text_y = 330\r\n                        screen.blit(text, (text_x, text_y))\r\n                        stroka = 'Подсказка: \"Почистите робота. Подойдите к нему и нажмите\"'\r\n                        text = font.render(stroka, True, (80, 80, 80))\r\n                        text_x = 320\r\n                        text_y = 330\r\n                        screen.blit(text, (text_x, text_y))\r\n                else:\r\n                    stroka = 'Может новости включить. Что за странные мысли, я их последний раз месяца 2 назад смотрел.'\r\n                    font = pygame.font.Font(None, 15)\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 310\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Хотя надо же быть немного в курсе событий. Пожалуй сегодня посмотрю.'\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 320\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Подсказка: \"Включите телевизор. Подойдите к нему и нажмите\"'\r\n                    text = font.render(stroka, True, (80, 80, 80))\r\n                    text_x = 10\r\n                    text_y = 330\r\n                    screen.blit(text, (text_x, text_y))\r\n            elif room == 3:\r\n                screen.blit(bg3, (0, 0))\r\n                all_sprites_room3.draw(screen)\r\n                pygame.draw.rect(screen, (255, 255, 255), (8, 308, 635, 35))\r\n                if flag_minigames3 is True:\r\n                    stroka = 'Наконец-то завтрак. Как же я люблю сырники. Я поел за 10 минут. Совершенно не хотелось торопиться.'\r\n                    font = pygame.font.Font(None, 15)\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 310\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Осталось только взять рюкзак и одеться. Надеюсь сегодня у меня будет хороший день.'\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 320\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Подсказка: \"Подойдите к двери и нажмите E\"'\r\n                    text = font.render(stroka, True, (80, 80, 80))\r\n                    text_x = 10\r\n                    text_y = 330\r\n                    screen.blit(text, (text_x, text_y))\r\n                else:\r\n                    stroka = 'Я умылся и почистил зубы. Теперь можно позавтракать. Но времени совсем мало осталось.'\r\n                    font = pygame.font.Font(None, 15)\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 310\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Через 15 минут уже надо из дома выходить. О мама оставила завтрак на столе. Надо подогреть.'\r\n                    text = font.render(stroka, True, (0, 0, 0))\r\n                    text_x = 10\r\n                    text_y = 320\r\n                    screen.blit(text, (text_x, text_y))\r\n                    stroka = 'Подсказка: \"Подогрейте завтрак. Подойдите к микроволновке и нажмите\"'\r\n                    text = font.render(stroka, True, (80, 80, 80))\r\n                    text_x = 10\r\n                    text_y = 330\r\n                    screen.blit(text, (text_x, text_y))\r\n        clock.tick(fps)\r\n        pygame.display.flip()\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef running2():  # первый цикл с начальной картинкой\r\n    pygame.init()\r\n    screen.blit(bg0, (0, 0))\r\n    pygame_icon = pygame.image.load(r'data\\ava.png')\r\n    pygame.display.set_icon(pygame_icon)  # меняю аватарку игры на лицо персонажа\r\n    pygame.display.set_caption('Лобби')\r\n    running = True\r\n    while running:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n            clock.tick(fps)\r\n            pygame.display.flip()\r\n            all_sprites_screen1.draw(screen)\r\n            all_sprites_screen1.update(event)  # обработка нажатия на кнопки\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef running4():  # цикл с каринкой об авторах\r\n    pygame.init()\r\n    screen.blit(bg0_1, (0, 0))\r\n    running = True\r\n    while running:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n            all_sprites_screen2.draw(screen)\r\n            all_sprites_screen2.update(event)\r\n            pygame.display.flip()\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef running5():  # цикл с конечной заставкой\r\n    pygame.init()\r\n    screen.blit(bg_end, (0, 0))\r\n    running = True\r\n    while running:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n            all_sprites_screen2.draw(screen)\r\n            all_sprites_screen2.update(event)\r\n            pygame.display.flip()\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef pers(flag1, rotate):  # вспомогательная функция, которая возвращает картинку персонажа\r\n    global flag  # а так же отвечает за изменение картинки на персонажа с шагом\r\n    if flag1 is True:  # таким образом на экране персонаж \"ходит\"\r\n        if rotate == 'r':\r\n            flag = False\r\n            return pr3\r\n        else:\r\n            flag = False\r\n            return pr4\r\n    else:\r\n        if rotate == 'r':\r\n            flag = True\r\n            return pr1\r\n        else:\r\n            flag = True\r\n            return pr2\r\n\r\n\r\nif __name__ == '__main__':  # запуск проекта\r\n    running2()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	
+++ b/main.py	
@@ -1132,7 +1132,7 @@
     pygame.display.set_caption('Игра')  # меняем заголовок окна
     shuffle(minigames)  # меняем последовательность в списке
     a = minigames.pop()  # берем элемент из списка, одновременно удалем число
-    # a = 1  # не забыть удалить!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+    a = 3  # не забыть удалить!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     if a == 0:  # вызываем игру в зависимости от числа
         Summas(screen, v)
     elif a == 1:
@@ -1272,7 +1272,7 @@
                 if room == 1 and event.key == 101 and person.rect.x >= 515 and flag_minigames1 is True:  # переход между комнатами
                     room = 2
                     person.rect.x = 0
-                elif room == 2 and event.key == 101 and person.rect.x <= 115:
+                elif room == 2 and event.key == 101 and person.rect.x <= 200:
                     room = 1
                     person.rect.x = 515
                 elif flag_minigames2 and event.key == 101 and person.rect.x >= 515 and flag_minigames2_2 and room == 2:
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"2ffaac0c-5681-44d7-837b-3507a76d3f89\" name=\"Changes\" comment=\"end_fix2\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/main.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/main.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"Master\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n    <option name=\"RESET_MODE\" value=\"KEEP\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2J39L7wesv7d3j4LSoyGTRj4Vk8\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python.main\">\r\n    <configuration name=\"main (1)\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"pygame-project\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/../test\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/../test/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"pygame-project\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.main\" />\r\n        <item itemvalue=\"Python.main (1)\" />\r\n        <item itemvalue=\"Python.main\" />\r\n        <item itemvalue=\"Python.main (1)\" />\r\n        <item itemvalue=\"Python.main\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"2ffaac0c-5681-44d7-837b-3507a76d3f89\" name=\"Changes\" comment=\"\" />\r\n      <created>1671295841274</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1671295841274</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"room-and-char\">\r\n      <created>1671300971286</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1671300971286</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"room-and-char-border\">\r\n      <created>1671301794812</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1671301794812</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"fix2\">\r\n      <created>1674555069168</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1674555069168</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"end_fix\">\r\n      <created>1674581525226</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1674581525227</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"end_fix2\">\r\n      <created>1674581545466</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1674581545466</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"6\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"FILTERS\">\r\n                <map>\r\n                  <entry key=\"branch\">\r\n                    <value>\r\n                      <list>\r\n                        <option value=\"room-test\" />\r\n                      </list>\r\n                    </value>\r\n                  </entry>\r\n                </map>\r\n              </option>\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"room-and-char\" />\r\n    <MESSAGE value=\"room-and-char-border\" />\r\n    <MESSAGE value=\"fix2\" />\r\n    <MESSAGE value=\"end_fix\" />\r\n    <MESSAGE value=\"end_fix2\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"end_fix2\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	
+++ b/.idea/workspace.xml	
@@ -2,7 +2,14 @@
 <project version="4">
   <component name="ChangeListManager">
     <list default="true" id="2ffaac0c-5681-44d7-837b-3507a76d3f89" name="Changes" comment="end_fix2">
-      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_23_01_2023_23_10__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_23_01_2023_23_10__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_23_01_2023_23_30__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_23_01_2023_23_30__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_24_01_2023_10_00__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_24_01_2023_10_00__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_24_01_2023_10_01__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_24_01_2023_10_01__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_24_01_2023_12_57__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_24_01_2023_12_57__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_23_01_2023_22_44__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_23_01_2023_22_44__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_23_01_2023_23_18__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_23_01_2023_23_18__Changes_.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_24_01_2023_10_04__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_24_01_2023_10_04__Changes_.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/main.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
